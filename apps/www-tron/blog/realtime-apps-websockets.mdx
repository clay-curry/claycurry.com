---
slug: realtime-apps-websockets
pinned: false
publishedDate: "12 Feb 2024"
title: Building Real-Time Applications with WebSockets
subtitle: Implement real-time features using WebSockets and modern frameworks
prefix: A deep dive into WebSocket protocols and patterns for building responsive, real-time web applications.
tags:
  - WebSockets
  - Real-time
  - Backend
readTime: "9 min"
image: "/software-architecture.jpg"
excerpt: Implement real-time features using WebSockets and modern frameworks.
---

# Building Real-Time Applications with WebSockets

<Summary>

WebSockets enable full-duplex communication between clients and servers, making them essential for real-time applications like chat systems, live dashboards, and collaborative tools. This guide covers the fundamentals and best practices.

</Summary>

## Why WebSockets?

Traditional HTTP follows a request-response model—the client asks, the server answers. But what happens when the server needs to push data to the client without being asked? That's where WebSockets shine.

> "The WebSocket protocol enables interaction between a web browser and a web server with lower overhead than half-duplex alternatives such as HTTP polling."

### HTTP vs WebSockets

| Feature | HTTP | WebSockets |
|---------|------|------------|
| Connection | New connection per request | Persistent connection |
| Direction | Client → Server | Bidirectional |
| Overhead | Headers on every request | Minimal after handshake |
| Use Case | REST APIs, page loads | Real-time updates, chat |

## Getting Started

### Server Setup (Node.js)

```typescript
import { WebSocketServer } from 'ws';

const wss = new WebSocketServer({ port: 8080 });

wss.on('connection', (ws) => {
  console.log('Client connected');

  ws.on('message', (data) => {
    // Broadcast to all connected clients
    wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(data.toString());
      }
    });
  });

  ws.on('close', () => {
    console.log('Client disconnected');
  });
});
```

### Client Setup (React)

```tsx
import { useEffect, useState, useCallback } from 'react';

function useWebSocket(url: string) {
  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [messages, setMessages] = useState<string[]>([]);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    const ws = new WebSocket(url);

    ws.onopen = () => setIsConnected(true);
    ws.onclose = () => setIsConnected(false);
    ws.onmessage = (event) => {
      setMessages((prev) => [...prev, event.data]);
    };

    setSocket(ws);

    return () => ws.close();
  }, [url]);

  const send = useCallback((message: string) => {
    socket?.send(message);
  }, [socket]);

  return { messages, send, isConnected };
}
```

## Common Patterns

### 1. Heartbeat / Ping-Pong

Keep connections alive and detect disconnects:

```typescript
const HEARTBEAT_INTERVAL = 30000;

wss.on('connection', (ws) => {
  ws.isAlive = true;

  ws.on('pong', () => {
    ws.isAlive = true;
  });
});

setInterval(() => {
  wss.clients.forEach((ws) => {
    if (!ws.isAlive) return ws.terminate();
    ws.isAlive = false;
    ws.ping();
  });
}, HEARTBEAT_INTERVAL);
```

### 2. Room-Based Broadcasting

Organize clients into rooms for targeted messaging:

```typescript
const rooms = new Map<string, Set<WebSocket>>();

function joinRoom(ws: WebSocket, roomId: string) {
  if (!rooms.has(roomId)) {
    rooms.set(roomId, new Set());
  }
  rooms.get(roomId)!.add(ws);
}

function broadcastToRoom(roomId: string, message: string) {
  rooms.get(roomId)?.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
}
```

### 3. Reconnection with Exponential Backoff

Handle disconnects gracefully on the client:

```typescript
function createReconnectingWebSocket(url: string) {
  let ws: WebSocket;
  let reconnectDelay = 1000;
  const maxDelay = 30000;

  function connect() {
    ws = new WebSocket(url);

    ws.onopen = () => {
      reconnectDelay = 1000; // Reset on successful connection
    };

    ws.onclose = () => {
      setTimeout(() => {
        reconnectDelay = Math.min(reconnectDelay * 2, maxDelay);
        connect();
      }, reconnectDelay);
    };
  }

  connect();
  return () => ws;
}
```

## Scaling WebSockets

When scaling beyond a single server, you need a pub/sub layer:

```typescript
import Redis from 'ioredis';

const pub = new Redis();
const sub = new Redis();

sub.subscribe('chat');

sub.on('message', (channel, message) => {
  // Broadcast to all local clients
  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
});

// When receiving a message from a client
ws.on('message', (data) => {
  pub.publish('chat', data.toString());
});
```

## Security Considerations

1. **Authentication**: Validate tokens during the WebSocket handshake
2. **Rate Limiting**: Prevent message flooding from malicious clients
3. **Input Validation**: Never trust client data—validate and sanitize
4. **TLS**: Always use `wss://` in production

```typescript
wss.on('connection', (ws, req) => {
  const token = new URL(req.url!, 'http://localhost').searchParams.get('token');

  if (!validateToken(token)) {
    ws.close(1008, 'Unauthorized');
    return;
  }

  // Proceed with authenticated connection
});
```

## Conclusion

WebSockets are powerful but require careful consideration of:

- **Connection management** (heartbeats, reconnection)
- **Scaling strategies** (Redis pub/sub, sticky sessions)
- **Security** (authentication, rate limiting)

Start simple, then add complexity as your application grows. The patterns in this guide will serve as a solid foundation for most real-time use cases.
